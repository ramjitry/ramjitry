Reference:
https://oracle-base.com/dba/scripts

How to kill blocking sessions.
-------------------------------
To find sql_id from sid
SQL> select sql_id from v$session where sid=&sid;

To find sql_full text from sql_id
SQL > select sql_fulltext from gv$sql where sql_id ="&SLQ_ID";

To kill sessions:
SQL> alter system kill session 'sid,serial#' immediate;

Query to show the allocated, Free and Used space in each of the datafiles
----------------------------------------------------------------------------
SELECT inst_id,SUBSTR (df.NAME, 1, 40) file_name, df.bytes / 1024 / 1024 allocated_mb,
((df.bytes / 1024 / 1024) - NVL (SUM (dfs.bytes) / 1024 / 1024, 0))
used_mb,
NVL (SUM (dfs.bytes) / 1024 / 1024, 0) free_space_mb
FROM gv$datafile df, dba_free_space dfs
WHERE df.file# = dfs.file_id(+)
GROUP BY dfs.file_id, df.NAME, df.file#, df.bytes,inst_id
ORDER BY file_name;

select d.free_mb/1024 free_GB, d.* from gV$ASM_DISKGROUP d;

Monitor long running operations using v$session_longops
-------------------------------------------------------
SELECT SID, SERIAL#, opname, SOFAR, TOTALWORK,
ROUND(SOFAR/TOTALWORK*100,2) COMPLETE
FROM   V$SESSION_LONGOPS
WHERE
TOTALWORK != 0
AND    SOFAR != TOTALWORK
order by 1;

Query can be used to monitor RMAN backup status
-----------------------------------------------
SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,
       ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE"
FROM V$SESSION_LONGOPS
WHERE OPNAME LIKE 'RMAN%'
  AND OPNAME NOT LIKE '%aggregate%'
  AND TOTALWORK != 0
  AND SOFAR  != TOTALWORK
  
Long Operation query
----------------------  
SELECT inst_id,
  sid,
  serial#,
  sofar Blocks_Processed,
  totalwork Total_Work,
  ROUND((sofar/totalwork)*100,2) Percentage_Completed,
  totalwork   -sofar Total_Work_Left,
  start_time Start_Time,
  ROUND((elapsed_seconds/60),0) Elapsed_Minutes,
  MESSAGE,
  username
FROM gv$session_longops
WHERE ROUND((sofar/totalwork)*100,2) <100
ORDER BY start_time DESC; 

Query to find sql using sid
----------------------------
SELECT a.sql_text
FROM   v$sqltext a,
       v$session b
WHERE  a.address = b.sql_address
AND    a.hash_value = b.sql_hash_value
AND    b.sid = '2397'
ORDER BY a.piece;

SELECT s.sid,
  s.status "Status",
  p.spid "Process",
  s.schemaname "Schema Name",
  s.osuser "OS User",
  SUBSTR(a.sql_text,1,120) "SQL Text",
  s.program "Program"
FROM v$session s,
  v$sqlarea a,
  v$process p
WHERE s.sql_hash_value = a.hash_value (+)
AND s.sql_address      = a.address (+)
AND s.paddr            = p.addr
AND s.sid              =2397;

Query run between specific time:
--------------------------------
SELECT sql_id, first_load_time, last_active_time, sql_text
FROM v$sqlarea
WHERE last_active_time BETWEEN TO_DATE ('19/10/2012 14:00:00',
'DD/MM/YYYY HH24:MI:SS'
)
AND TO_DATE ('19/10/2012 15:00:00',
'DD/MM/YYYY HH24:MI:SS'
); SELECT sql_id, first_load_time, last_active_time, sql_text
FROM v$sqlarea
WHERE last_active_time BETWEEN TO_DATE ('19/10/2012 14:00:00',
'DD/MM/YYYY HH24:MI:SS'
)
AND TO_DATE ('19/10/2012 15:00:00',
'DD/MM/YYYY HH24:MI:SS'
);

Displays the High Water Mark for the specified table
----------------------------------------------------

DECLARE
  CURSOR cu_tables IS
    SELECT a.owner,
           a.table_name
    FROM   all_tables a
    WHERE  a.table_name = 'TL_PYMT_BATCH'
    AND    a.owner      = 'STS_TH_DBA';

  op1  NUMBER;
  op2  NUMBER;
  op3  NUMBER;
  op4  NUMBER;
  op5  NUMBER;
  op6  NUMBER;
  op7  NUMBER;
BEGIN

  Dbms_Output.Disable;
  Dbms_Output.Enable(1000000);
  Dbms_Output.Put_Line('TABLE                             UNUSED BLOCKS     TOTAL BLOCKS  HIGH WATER MARK');
  Dbms_Output.Put_Line('------------------------------  ---------------  ---------------  ---------------');
  FOR cur_rec IN cu_tables LOOP
    Dbms_Space.Unused_Space(cur_rec.owner,cur_rec.table_name,'TABLE',op1,op2,op3,op4,op5,op6,op7);
    Dbms_Output.Put_Line(RPad(cur_rec.table_name,30,' ') ||
                         LPad(op3,15,' ')                ||
                         LPad(op1,15,' ')                ||
                         LPad(Trunc(op1-op3-1),15,' ')); 
  END LOOP;

END;

Query to check wether given table is locked or not
--------------------------------------------------
SELECT a.sid,
  A.STATUS,
  a.serial#,
  a.process
FROM gv$session a,
  gv$locked_object b,
  dba_objects c
WHERE b.object_id = c.object_id
AND a.sid         = b.session_id
AND OBJECT_NAME   ='TL_RT_TRAN';

Query to find all locked objects
---------------------------------
SELECT b.inst_id,
       b.session_id AS sid,
       NVL(b.oracle_username, '(oracle)') AS username,
       a.owner AS object_owner,
       a.object_name,
       Decode(b.locked_mode, 0, 'None',
                             1, 'Null (NULL)',
                             2, 'Row-S (SS)',
                             3, 'Row-X (SX)',
                             4, 'Share (S)',
                             5, 'S/Row-X (SSX)',
                             6, 'Exclusive (X)',
                             b.locked_mode) locked_mode,
       b.os_user_name
FROM   dba_objects a,
       gv$locked_object b
WHERE  a.object_id = b.object_id
ORDER BY 1, 2, 3, 4;

Query to see blocking and blocker sessions
------------------------------------------

SELECT
  (SELECT username FROM v$session WHERE sid=a.sid
  ) blocker,
  a.sid,
  ' is blocking ',
  (SELECT username FROM v$session WHERE sid=b.sid
  ) blockee,
  b.sid
FROM v$lock a,
  v$lock b
WHERE a.block = 1
AND b.request > 0
AND a.id1     = b.id1
AND a.id2     = b.id2;

SELECT l1.inst_id,
  l1.sid,
  ' IS BLOCKING ',
  l2.sid,
  l1.type,
  l2.type,
  l1.lmode,
  l2.lmode,
  l2.inst_id
FROM gv$lock l1,
  gv$lock l2
WHERE l1.block =1
AND l2.request > 0
AND l1.id1     =l2.id1
AND l1.id2     =l2.id2; 

SELECT hld.inst_id,
  (SELECT machine||'-'||osuser||'-'||status||'-'||hld.type||'~'||sid||'-'||serial# FROM gv$session WHERE sid=hld.sid AND inst_id=hld.inst_id) holder_details,
  (SELECT machine||'-'||osuser||'-'||status||'-'||wt.type||'~'||sid||'-'||serial# FROM gv$session WHERE sid=wt.sid AND inst_id=wt.inst_id) waiter_details,
  (SELECT sql_fulltext FROM gv$session s, gv$sql sq WHERE s.sid=hld.sid AND s.inst_id=hld.inst_id and s.inst_id=sq.inst_id and s.sql_id=sq.sql_id) holder_sql,
  (SELECT sql_fulltext FROM gv$session s, gv$sql sq WHERE s.sid=wt.sid AND s.inst_id=wt.inst_id and s.inst_id=sq.inst_id and s.sql_id=sq.sql_id) waiter_sql
FROM gv$lock hld,
  gv$lock wt
WHERE hld.block =1
AND wt.request  > 0
AND hld.id1     =wt.id1
AND hld.id2     =wt.id2
AND hld.inst_id =wt.inst_id;

select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
   gv$locked_object a ,
   gv$session b,
   dba_objects c
where b.sid = a.session_id
and  a.object_id = c.object_id;

   SELECT s.inst_id,
       s.sid,
       s.serial#,
       --s.sql_id,
       p.spid,
       s.username,
       s.program
FROM   gv$session s
       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id
WHERE  s.type != 'BACKGROUND';

------------------------------

to get psid:-

SELECT
  p.spid                      unix_spid,
  s.sid                       sid,
  p.addr,
  s.paddr,
  substr(s.username, 1, 10)   username,
  substr(s.schemaname, 1, 10) schemaname,
  s.command                   command,
  substr(s.osuser, 1, 10)     osuser,
  substr(s.machine, 1, 25)    machine
FROM   v$session s, v$process p
WHERE  s.paddr=p.addr
ORDER BY p.spid;

-----------------------------

	Select * from dba_2pc_pending;  -- check if there are any transactions with prepared / pending status
	If yes, run the following scripts in respective DB connecting via putty

o	SQL> Rollback Force '48.33.10715';   -- To force rollback using LOCAL_TRAN_ID
o	SQL> Commit;
o	SQL> execute DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY('48.33.10715'); -- To clear any locks held by in-doubt transaction 


---------------------------------------------

table size:-

select * from (
SELECT owner, table_name, ROUND(sum(bytes)/1024/1024, 2) MB
    FROM
    (SELECT segment_name table_name, owner, bytes
     FROM dba_segments
     WHERE segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
     UNION ALL
     SELECT i.table_name, i.owner, s.bytes
     FROM dba_indexes i, dba_segments s
     WHERE s.segment_name = i.index_name
     AND   s.owner = i.owner
     AND   s.segment_type IN ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
     UNION ALL
